<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [第16课-驱动访问大揭秘](#第16课-驱动访问大揭秘)
	- [驱动访问模型](#驱动访问模型)
	- [read系统调用分析](#read系统调用分析)
		- [系统调用入口](#系统调用入口)
		- [系统调用表](#系统调用表)
		- [分析sys_read](#分析sysread)
	- [总结](#总结)

<!-- /TOC -->

# 第16课-驱动访问大揭秘

## 驱动访问模型

![1526779453700.png](image/1526779453700.png)

## read系统调用分析

![1526779548258.png](image/1526779548258.png)

      read如何找到内核驱动中的read操作？

![1526779612452.png](image/1526779612452.png)

![1526779627129.png](image/1526779627129.png)

![1526779639418.png](image/1526779639418.png)

![1526779647201.png](image/1526779647201.png)

![1526779683298.png](image/1526779683298.png)

      调用_libc_read

![1526779707890.png](image/1526779707890.png)

      3传递给r7，然后调用svc，系统调用指令。进入内核态。
      入口固定，进入内核后获取参数3表明调用第三个系统调用read
      根据3参数查表，函数地址表，调用sys_read函数，

![1526779836488.png](image/1526779836488.png)

### 系统调用入口

![1526779903091.png](image/1526779903091.png)

### 系统调用表

![1526779932969.png](image/1526779932969.png)

      全局搜索一波

![1526779945143.png](image/1526779945143.png)

![1526779957785.png](image/1526779957785.png)

      包含了calls.S

![1526779975621.png](image/1526779975621.png)


### 分析sys_read

      直接搜索sys_read不得行

![1526780077486.png](image/1526780077486.png)

      在read_write.c中

![1526780082847.png](image/1526780082847.png)

![1526780090768.png](image/1526780090768.png)

      宏SYSCALL_DEFINE3其实就是转换成常见函数
      3表示函数参数
      通过文件描述符找到 struct file
      然后调用vfs_read

![1526780222669.png](image/1526780222669.png)

      这行代码是整个代码关键
      找到对应文件描述符中提供的文件操作集的read方法

## 总结


![1526780362824.png](image/1526780362824.png)
