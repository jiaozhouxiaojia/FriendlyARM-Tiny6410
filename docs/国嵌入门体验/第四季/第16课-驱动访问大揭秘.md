<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [第16课-驱动访问大揭秘](#第16课-驱动访问大揭秘)
	- [驱动访问模型](#驱动访问模型)
	- [read系统调用分析](#read系统调用分析)
	- [系统调用入口](#系统调用入口)
	- [系统调用表](#系统调用表)
	- [总结](#总结)

<!-- /TOC -->

# 第16课-驱动访问大揭秘

## 驱动访问模型

![1526779453700.png](image/1526779453700.png)

## read系统调用分析

![1526779548258.png](image/1526779548258.png)

      read如何找到内核驱动中的read操作？

![1526779612452.png](image/1526779612452.png)

![1526779627129.png](image/1526779627129.png)

![1526779639418.png](image/1526779639418.png)

![1526779647201.png](image/1526779647201.png)

![1526779683298.png](image/1526779683298.png)

      调用_libc_read

![1526779707890.png](image/1526779707890.png)

      3传递给r7，然后调用svc，系统调用指令。进入内核态。
      入口固定，进入内核后获取参数3表明调用第三个系统调用read
      根据3参数查表，函数地址表，调用sys_read函数，

![1526779836488.png](image/1526779836488.png)

## 系统调用入口

![1526779903091.png](image/1526779903091.png)

## 系统调用表

![1526779932969.png](image/1526779932969.png)

      全局搜索一波

![1526779945143.png](image/1526779945143.png)

![1526779957785.png](image/1526779957785.png)

      包含了calls.S

![1526779975621.png](image/1526779975621.png)


## 总结
