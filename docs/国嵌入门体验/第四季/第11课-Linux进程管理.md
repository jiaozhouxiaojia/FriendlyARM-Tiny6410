# 第11课-Linux进程管理

## 课程索引


![1526699773561.png](image/1526699773561.png)


## 进程要素

### 进程与程序

![1526699864484.png](image/1526699864484.png)

      程序是死的，进程是活的

### 进程4要素

      通过PCB控制进程

![1526699890849.png](image/1526699890849.png)

![1526699898632.png](image/1526699898632.png)

      通过有无用户空间区分用户进程和内核进程

### 进程状态

![1526699927173.png](image/1526699927173.png)

![1526700136606.png](image/1526700136606.png)

![1526704303779.png](image/1526704303779.png)

      就绪和执行都是TASK_RUNNING

![1526704320082.png](image/1526704320082.png)

      不可以被打断，就算发送唤醒信号也没有用。

![1526704493833.png](image/1526704493833.png)

      不止六种状态

### 进程描述结构

![1526704523247.png](image/1526704523247.png)

      task_struct 就是 PCB

![1526704548149.png](image/1526704548149.png)

## Linux进程调度

![1526704588854.png](image/1526704588854.png)

### 什么是调度

![1526704607069.png](image/1526704607069.png)

### 调度策略

![1526704648520.png](image/1526704648520.png)

### 调度时机

![1526704656974.png](image/1526704656974.png)

![1526704664983.png](image/1526704664983.png)

      自定义成阻塞态，阻塞是自发的操作，自己阻塞自己。

![1526704683429.png](image/1526704683429.png)

![1526704691354.png](image/1526704691354.png)

![1526704700784.png](image/1526704700784.png)

![1526704707804.png](image/1526704707804.png)

![1526704715999.png](image/1526704715999.png)

![1526704722269.png](image/1526704722269.png)



### 调度步骤

![1526704731421.png](image/1526704731421.png)




## 总结
